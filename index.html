<!DOCTYPE html>
<html>
<head>
    <title>tool-SeedFreedomCampaign</title>
    <style>
        @font-face {
            font-family: 'New Spirit';
            src: url('fonts/New Spirit SemiBold.otf') format('opentype');
            font-weight: 600;
            font-style: normal;
        }
        
        * {
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'New Spirit', sans-serif;
            background-color: #ffffff;
        }
        
        .container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
        }
        
        .side-footer {
            position: absolute;
            left: 0;
            top: 0;
            width: 2.5%;
            height: 100%;
            background-color: #ffffff;
        }
        
        .gallery {
            position: absolute;
            left: 2.5%;
            top: 0;
            width: 67.5%;
            height: 100%;
            background-color: #2e2626;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .canvas-wrapper {
            background-color: #ffffff;
            transition: width 0.3s, height 0.3s;
            max-width: 100%;
            max-height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        .p5-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .p5-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .text-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        
        .text-content {
            font-family: 'New Spirit', sans-serif;
            font-size: 85px; /* Updated to 85px */
            color: #000000;
            text-align: center;
            line-height: 1.1;
            padding: 20px;
            max-width: 90%;
            word-wrap: break-word;
            text-wrap: pretty;
            hanging-punctuation: first last;
            text-transform: uppercase;
            hyphens: auto; /* Added hyphenation */
            -webkit-hyphens: auto; /* Safari support */
            -ms-hyphens: auto; /* IE/Edge support */
        }
        
        .controls {
            position: absolute;
            right: 0;
            top: 0;
            width: 30%;
            height: 100%;
            background-color: #ffffff;
            padding: 48px;
            color: #2e2626;
            text-wrap: pretty;
            hanging-punctuation: first last;
        }
        
        .row-grid {
            display: grid;
            grid-template-rows: 1fr 10px 27px auto auto 10px 27px auto 1.25fr 0.75fr 0.75fr 27px;
            height: 100%;
            gap: 0;
        }
        
        .title-section {
            grid-row: 1;
            font-size: 50px;
            line-height: 100%;
            color: #2e2626;
            text-wrap: pretty;
            hanging-punctuation: first last;
        }
        
        .spacing-row-1 {
            grid-row: 2;
        }
        
        .divider {
            grid-row: 3;
            height: 4px;
            background-color: #2e2626;
            align-self: center;
            width: 100%;
        }
        
        .canvas-section {
            grid-row: 4;
            font-size: 30px;
            color: #2e2626;
            text-wrap: pretty;
            hanging-punctuation: first last;
            display: flex;
            align-items: flex-start;
        }
        
        .aspect-ratio-buttons {
            grid-row: 5;
            display: flex;
            width: 100%;
            height: 50px;
            gap: 24px;
            margin-top: 10px;
        }
        
        .aspect-button {
            flex: 1;
            background-color: #ffffff;
            border: 2px solid #2e2626;
            border-radius: 12.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #2e2626;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            text-wrap: pretty;
            hanging-punctuation: first last;
        }
        
        .aspect-button:hover {
            background-color: #f0f0f0;
        }
        
        .aspect-button.active {
            background-color: #2e2626;
            color: #ffffff;
        }
        
        .spacing-row-2 {
            grid-row: 6;
        }
        
        .divider2 {
            grid-row: 7;
            height: 4px;
            background-color: #2e2626;
            align-self: center;
            width: 100%;
        }
        
        .type-pun-section {
            grid-row: 8;
            font-size: 30px;
            text-wrap: pretty;
            hanging-punctuation: first last;
            display: flex;
            align-items: flex-start;
        }
        
        .character-counter {
            font-size: 14px;
            color: #999;
            margin-top: 5px;
            text-align: right;
        }
        
        .character-counter.warning {
            color: #ff6b6b;
        }
        
        .character-counter.max {
            color: #ff0000;
        }
        
        .type-input-section {
            grid-row: 9;
            width: 100%;
            height: 100%;
            margin-top: 10px;
        }
        
        .type-input {
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            border: 2px solid #2e2626;
            border-radius: 12.5px;
            font-family: 'New Spirit', sans-serif;
            font-size: 20px;
            color: #2e2626;
            padding: 15px;
            box-sizing: border-box;
            resize: none;
            outline: none;
            text-wrap: pretty;
            hanging-punctuation: first last;
            text-transform: uppercase;
        }
        
        .type-input::placeholder {
            color: #999;
            text-transform: none;
        }
        
        .type-input:focus {
            border-color: #2e2626;
            box-shadow: 0 0 0 2px rgba(46, 38, 38, 0.1);
        }
        
        .button-section {
            grid-row: 11;
            display: flex;
            width: 100%;
            height: 50px;
            gap: 24px;
        }
        
        .randomise-button {
            background-color: #ffffff;
            border: 2px solid #2e2626;
            border-radius: 12.5px;
            font-family: 'New Spirit', sans-serif;
            font-size: 20px;
            color: #2e2626;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            text-wrap: pretty;
            hanging-punctuation: first last;
            flex: 4;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .randomise-button:hover {
            background-color: #2e2626;
            color: #ffffff;
        }
        
        .download-button {
            background-color: #ffffff;
            border: 2px solid #2e2626;
            border-radius: 12.5px;
            font-family: 'New Spirit', sans-serif;
            color: #2e2626;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .download-button:hover {
            background-color: #2e2626;
        }
        
        .download-button:hover .download-icon {
            filter: brightness(0) invert(1);
        }
        
        .download-icon {
            width: 26px;
            height: 26px;
            object-fit: fill;
        }
        
        .bottom-margin {
            grid-row: 10;
        }
        
        .spacing-row-3 {
            grid-row: 12;
        }
        
        /* Responsive adjustments */
        @media (max-height: 800px) {
            .controls {
                padding: 30px;
            }
            
            .title-section {
                font-size: 40px;
            }
            
            .canvas-section, .type-pun-section {
                font-size: 24px;
            }
            
            .aspect-button, .type-input, .randomise-button {
                font-size: 16px;
            }
            
            .aspect-ratio-buttons, .button-section {
                height: 40px;
            }
            
            .aspect-button, .randomise-button {
                border-radius: 10px;
            }
            
            .type-input {
                padding: 10px;
                font-size: 16px;
            }
            
            .text-content {
                font-size: 65px;
            }
        }
        
        @media (max-height: 600px) {
            .controls {
                padding: 20px;
            }
            
            .title-section {
                font-size: 32px;
            }
            
            .canvas-section, .type-pun-section {
                font-size: 20px;
            }
            
            .aspect-button, .type-input, .randomise-button {
                font-size: 14px;
            }
            
            .aspect-ratio-buttons, .button-section {
                height: 35px;
            }
            
            .aspect-button, .randomise-button {
                border-radius: 8px;
            }
            
            .type-input {
                padding: 8px;
                font-size: 14px;
            }
            
            .text-content {
                font-size: 50px;
            }
        }
        
        @media (max-width: 1400px) {
            .text-content {
                font-size: 70px;
            }
        }
        
        @media (max-width: 1200px) {
            .text-content {
                font-size: 60px;
            }
        }
        
        @media (max-width: 1000px) {
            .text-content {
                font-size: 55px;
            }
        }
        
        @media (max-width: 800px) {
            .text-content {
                font-size: 50px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="side-footer">
            <!-- Side footer text removed as requested -->
        </div>
        <div class="gallery" id="gallery">
            <div class="canvas-wrapper" id="canvas-wrapper">
                <div class="p5-container" id="p5-container"></div>
                <div class="text-overlay" id="text-overlay">
                    <div class="text-content" id="text-content"></div>
                </div>
            </div>
        </div>
        <div class="controls">
            <div class="row-grid">
                <div class="title-section">
                    Seed Freedom <br>Poster Generator
                </div>
                
                <div class="spacing-row-1"></div>
                
                <div class="divider"></div>
                
                <div class="canvas-section">
                    Canvas Size 
                </div>
                
                <div class="aspect-ratio-buttons">
                    <div class="aspect-button" data-aspect="16:9">16:9</div>
                    <div class="aspect-button" data-aspect="9:16">9:16</div>
                    <div class="aspect-button" data-aspect="4:5">4:5</div>
                    <div class="aspect-button" data-aspect="3:2" id="btn-3x2">3:2</div>
                    <div class="aspect-button" data-aspect="1:1">1:1</div>
                </div>
                
                <div class="spacing-row-2"></div>
                
                <div class="divider2"></div>
                
                <div class="type-pun-section">
                    Add Your Pun
                </div>
                
                <div class="type-input-section">
                    <textarea class="type-input" placeholder="Type your pun here..." id="pun-input" maxlength="30"></textarea>
                    <div class="character-counter" id="character-counter">0/30</div>
                </div>
                
                <div class="bottom-margin"></div>
                
                <div class="button-section">
                    <div class="randomise-button" id="randomise-btn">Randomise</div>
                    <div class="download-button" id="download-btn">
                        <img src="Icons/SFC-Tool-Favicon.svg" alt="Download" class="download-icon">
                    </div>
                </div>
                
                <div class="spacing-row-3"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Rectangle size ratios for container sizing
        const sizeRatios = [
            {width: 69.44, height: 46.875},    // 16:9 (900x506.25)
            {width: 39.06, height: 83.33},     // 9:16 (506.25x900)
            {width: 55.56, height: 83.33},     // 4:5 (720x900)
            {width: 69.44, height: 55.56},     // 3:2 (900x600)
            {width: 69.44, height: 83.33}      // 1:1 (900x900)
        ];
        
        // Canvas dimensions for each sketch (fixed sizes from the second file)
        const canvasDimensions = {
            '16:9': { width: 900, height: 506.25 },
            '9:16': { width: 506.25, height: 900 },
            '4:5': { width: 720, height: 900 },
            '3:2': { width: 900, height: 600 },
            '1:1': { width: 900, height: 900 }
        };
        
        let currentSizeIndex = 3; // Start with 3:2 (index 3)
        let currentP5Instance = null;
        let currentSketch = null;
        const MAX_CHARACTERS = 30;
        
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const p5Container = document.getElementById('p5-container');
        const gallery = document.getElementById('gallery');
        const textContent = document.getElementById('text-content');
        const punInput = document.getElementById('pun-input');
        const characterCounter = document.getElementById('character-counter');
        
        // Initialize download counter from session storage
        let downloadCounter = sessionStorage.getItem('sfc_download_counter') || 0;
        
        // Initialize with 3:2 size
        updateCanvasWrapperSize();
        
        function updateCanvasWrapperSize() {
            const galleryRect = gallery.getBoundingClientRect();
            const galleryWidth = galleryRect.width;
            const galleryHeight = galleryRect.height;
            
            const ratio = sizeRatios[currentSizeIndex];
            
            // Calculate size based on percentage of gallery dimensions
            const width = Math.min(
                galleryWidth * (ratio.width / 100),
                galleryWidth * 0.9
            );
            
            const height = Math.min(
                galleryHeight * (ratio.height / 100),
                galleryHeight * 0.9
            );
            
            canvasWrapper.style.width = `${width}px`;
            canvasWrapper.style.height = `${height}px`;
            
            // Update text overlay size
            updateTextOverlay();
        }
        
        function updateActiveButton() {
            // Remove active class from all buttons
            document.querySelectorAll('.aspect-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Map current size index to aspect ratio
            const aspectMap = ['16:9', '9:16', '4:5', '3:2', '1:1'];
            const currentAspect = aspectMap[currentSizeIndex];
            
            // Add active class to corresponding button
            const activeButton = document.querySelector(`[data-aspect="${currentAspect}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }
        
        function updateTextOverlay() {
            let text = punInput.value.trim().toUpperCase();
            
            // Add full stop if text exists and doesn't already end with punctuation
            if (text.length > 0) {
                const lastChar = text.charAt(text.length - 1);
                if (!['.', '!', '?', ':', ';'].includes(lastChar)) {
                    text += '.';
                }
            }
            
            textContent.textContent = text;
            
            // Update character counter (count without the added full stop)
            const rawText = punInput.value.trim().toUpperCase();
            const charCount = rawText.length;
            characterCounter.textContent = `${charCount}/${MAX_CHARACTERS}`;
            
            // Update counter color based on character count
            characterCounter.classList.remove('warning', 'max');
            if (charCount > MAX_CHARACTERS * 0.8) {
                characterCounter.classList.add('warning');
            }
            if (charCount >= MAX_CHARACTERS) {
                characterCounter.classList.add('max');
            }
        }
        
        function downloadCanvas() {
            // Get text from input (without the auto-added period for filename)
            const inputText = punInput.value.trim().toUpperCase();
            const filenameText = inputText.replace(/[^A-Z0-9]/g, '_').substring(0, 20) || 'NO_TEXT';
            
            // Increment download counter and save to session storage
            downloadCounter++;
            sessionStorage.setItem('sfc_download_counter', downloadCounter);
            
            // Create filename
            const filename = `${filenameText}_SFC_Poster_${downloadCounter}.jpg`;
            
            // Use html2canvas to capture the canvas wrapper
            html2canvas(canvasWrapper, {
                backgroundColor: '#ffffff',
                scale: 2, // Higher resolution for better quality
                useCORS: true,
                logging: false,
                allowTaint: true
            }).then(canvas => {
                // Convert canvas to data URL
                const imageData = canvas.toDataURL('image/jpeg', 0.95);
                
                // Create download link
                const link = document.createElement('a');
                link.download = filename;
                link.href = imageData;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(`Downloaded: ${filename}`);
            }).catch(error => {
                console.error('Error capturing canvas:', error);
                alert('Error downloading image. Please try again.');
            });
        }
        
        // Load p5.js sketch based on aspect ratio
        function loadSketch(aspectRatio) {
            // Remove existing sketch if any
            if (currentSketch) {
                currentSketch.remove();
                currentSketch = null;
                currentP5Instance = null;
            }
            
            // Clear p5 container
            p5Container.innerHTML = '';
            
            // Load appropriate sketch based on aspect ratio
            switch(aspectRatio) {
                case '3:2':
                    load3x2Sketch();
                    break;
                case '1:1':
                    load1x1Sketch();
                    break;
                case '4:5':
                    load4x5Sketch();
                    break;
                case '9:16':
                    load9x16Sketch();
                    break;
                case '16:9':
                    load16x9Sketch();
                    break;
                default:
                    // Default to 3:2
                    load3x2Sketch();
            }
        }
        
        // 3:2 sketch - EXACTLY AS PROVIDED
        function load3x2Sketch() {
            const sketch = function(p) {
                p.images = [];
                p.selectedIndices = [];
                p.scalePercent = 0.9;
                
                // Dot grid variables
                p.dotRows = 10;
                p.dotCols = 10;
                p.dotSize = 6;
                
                // Color palette
                p.colors = [
                    {r: 168, g: 31, b: 35},
                    {r: 239, g: 214, b: 21},
                    {r: 232, g: 114, b: 36},
                    {r: 39, g: 76, b: 35},
                    {r: 28, g: 90, b: 153}
                ];
                
                p.areaDots = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                };
                
                p.preload = function() {
                    // Load all 11 images
                    for (let i = 1; i <= 11; i++) {
                        const num = i.toString().padStart(2, '0');
                        p.images[i-1] = p.loadImage(`images/Riso-Illustrations-${num}.jpg`);
                    }
                };
                
                p.setup = function() {
                    // Use fixed dimensions from the second file
                    const canvas = p.createCanvas(900, 600);
                    // Create a wrapper div for the canvas
                    const canvasElement = canvas.elt;
                    const canvasDiv = document.createElement('div');
                    canvasDiv.className = 'p5-canvas';
                    canvasDiv.style.width = '100%';
                    canvasDiv.style.height = '100%';
                    canvasDiv.style.display = 'flex';
                    canvasDiv.style.justifyContent = 'center';
                    canvasDiv.style.alignItems = 'center';
                    canvasDiv.appendChild(canvasElement);
                    p5Container.appendChild(canvasDiv);
                    
                    // Select 4 random unique images
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    
                    // Calculate which dots belong to which area
                    p.calculateAreaDots();
                    
                    // Draw once
                    p.drawImages();
                };
                
                p.calculateAreaDots = function() {
                    // Clear previous areas
                    for (let area in p.areaDots) {
                        p.areaDots[area] = [];
                    }
                    
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    const topHeight = p.height * 0.3;
                    const bottomHeight = p.height * 0.7;
                    const leftWidth = p.width * 0.3;
                    const rightWidth = p.width * 0.7;
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            
                            if (y < topHeight) {
                                p.areaDots.top.push({x: x, y: y, row: row, col: col});
                            } else if (x > rightWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.right.push({x: x, y: y, row: row, col: col});
                                }
                            } else if (y > bottomHeight) {
                                p.areaDots.bottom.push({x: x, y: y, row: row, col: col});
                            } else if (x < leftWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.left.push({x: x, y: y, row: row, col: col});
                                }
                            }
                        }
                    }
                };
                
                p.drawImages = function() {
                    p.background(255);
                    
                    // Draw dot grid
                    p.drawDotGrid();
                    
                    p.blendMode(p.MULTIPLY);
                    
                    const areas = ["top", "right", "bottom", "left"];
                    let shuffledAreas = p.shuffleArray([...areas]);
                    
                    let selectedColors = [];
                    let availableColorIndices = [0, 1, 2, 3, 4];
                    
                    while (selectedColors.length < 4) {
                        let r = p.floor(p.random(availableColorIndices.length));
                        let colorIndex = availableColorIndices[r];
                        selectedColors.push(p.colors[colorIndex]);
                        availableColorIndices.splice(r, 1);
                    }
                    
                    for (let i = 0; i < p.selectedIndices.length; i++) {
                        let img = p.images[p.selectedIndices[i]];
                        let area = shuffledAreas[i];
                        let color = selectedColors[i];
                        
                        if (img && img.width > 0 && p.areaDots[area].length > 0) {
                            let coloredImage = p.colorizeImage(img, color);
                            
                            let w = img.width * p.scalePercent;
                            let h = img.height * p.scalePercent;
                            
                            let randomDot = p.random(p.areaDots[area]);
                            
                            let x = randomDot.x - w/2;
                            let y = randomDot.y - h/2;
                            
                            p.image(coloredImage, x, y, w, h);
                        }
                    }
                    
                    p.blendMode(p.BLEND);
                };
                
                p.colorizeImage = function(img, color) {
                    let colored = p.createGraphics(img.width, img.height);
                    
                    colored.image(img, 0, 0);
                    
                    colored.loadPixels();
                    img.loadPixels();
                    
                    for (let i = 0; i < img.pixels.length; i += 4) {
                        let r = img.pixels[i];
                        let g = img.pixels[i + 1];
                        let b = img.pixels[i + 2];
                        let a = img.pixels[i + 3];
                        
                        let brightness = (r + g + b) / 3;
                        let factor = brightness / 255;
                        
                        colored.pixels[i] = color.r * (1 - factor) + 255 * factor;
                        colored.pixels[i + 1] = color.g * (1 - factor) + 255 * factor;
                        colored.pixels[i + 2] = color.b * (1 - factor) + 255 * factor;
                        colored.pixels[i + 3] = a;
                    }
                    
                    colored.updatePixels();
                    return colored;
                };
                
                p.drawDotGrid = function() {
                    p.fill(255);
                    p.noStroke();
                    
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            p.ellipse(x, y, p.dotSize, p.dotSize);
                        }
                    }
                };
                
                p.shuffleArray = function(array) {
                    let shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        let j = p.floor(p.random(i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };
                
                p.randomise = function() {
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    
                    p.drawImages();
                };
                
                p.mousePressed = function() {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        p.randomise();
                    }
                };
            };
            
            currentSketch = new p5(sketch);
            currentP5Instance = currentSketch;
        }
        
        // 1:1 sketch - EXACTLY AS PROVIDED
        function load1x1Sketch() {
            const sketch = function(p) {
                p.images = [];
                p.selectedIndices = [];
                p.scalePercent = 0.92;
                
                // Dot grid variables
                p.dotRows = 10;
                p.dotCols = 10;
                p.dotSize = 6;
                
                // Color palette
                p.colors = [
                    {r: 168, g: 31, b: 35},
                    {r: 239, g: 214, b: 21},
                    {r: 232, g: 114, b: 36},
                    {r: 39, g: 76, b: 35},
                    {r: 28, g: 90, b: 153}
                ];
                
                p.areaDots = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                };
                
                p.preload = function() {
                    // Load all 11 images
                    for (let i = 1; i <= 11; i++) {
                        const num = i.toString().padStart(2, '0');
                        p.images[i-1] = p.loadImage(`images/Riso-Illustrations-${num}.jpg`);
                    }
                };
                
                p.setup = function() {
                    // Use fixed dimensions from the second file
                    const canvas = p.createCanvas(900, 900);
                    // Create a wrapper div for the canvas
                    const canvasElement = canvas.elt;
                    const canvasDiv = document.createElement('div');
                    canvasDiv.className = 'p5-canvas';
                    canvasDiv.style.width = '100%';
                    canvasDiv.style.height = '100%';
                    canvasDiv.style.display = 'flex';
                    canvasDiv.style.justifyContent = 'center';
                    canvasDiv.style.alignItems = 'center';
                    canvasDiv.appendChild(canvasElement);
                    p5Container.appendChild(canvasDiv);
                    
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    
                    p.calculateAreaDots();
                    p.drawImages();
                };
                
                p.calculateAreaDots = function() {
                    for (let area in p.areaDots) {
                        p.areaDots[area] = [];
                    }
                    
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    const topHeight = p.height * 0.32;
                    const bottomHeight = p.height * 0.68;
                    const leftWidth = p.width * 0.32;
                    const rightWidth = p.width * 0.72;
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            
                            if (y < topHeight) {
                                p.areaDots.top.push({x: x, y: y, row: row, col: col});
                            } else if (x > rightWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.right.push({x: x, y: y, row: row, col: col});
                                }
                            } else if (y > bottomHeight) {
                                p.areaDots.bottom.push({x: x, y: y, row: row, col: col});
                            } else if (x < leftWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.left.push({x: x, y: y, row: row, col: col});
                                }
                            }
                        }
                    }
                };
                
                p.drawImages = function() {
                    p.background(255);
                    p.drawDotGrid();
                    p.blendMode(p.MULTIPLY);
                    
                    const areas = ["top", "right", "bottom", "left"];
                    let shuffledAreas = p.shuffleArray([...areas]);
                    
                    let selectedColors = [];
                    let availableColorIndices = [0, 1, 2, 3, 4];
                    
                    while (selectedColors.length < 4) {
                        let r = p.floor(p.random(availableColorIndices.length));
                        let colorIndex = availableColorIndices[r];
                        selectedColors.push(p.colors[colorIndex]);
                        availableColorIndices.splice(r, 1);
                    }
                    
                    for (let i = 0; i < p.selectedIndices.length; i++) {
                        let img = p.images[p.selectedIndices[i]];
                        let area = shuffledAreas[i];
                        let color = selectedColors[i];
                        
                        if (img && img.width > 0 && p.areaDots[area].length > 0) {
                            let coloredImage = p.colorizeImage(img, color);
                            let w = img.width * p.scalePercent;
                            let h = img.height * p.scalePercent;
                            let randomDot = p.random(p.areaDots[area]);
                            let x = randomDot.x - w/2;
                            let y = randomDot.y - h/2;
                            p.image(coloredImage, x, y, w, h);
                        }
                    }
                    
                    p.blendMode(p.BLEND);
                };
                
                p.colorizeImage = function(img, color) {
                    let colored = p.createGraphics(img.width, img.height);
                    colored.image(img, 0, 0);
                    colored.loadPixels();
                    img.loadPixels();
                    
                    for (let i = 0; i < img.pixels.length; i += 4) {
                        let r = img.pixels[i];
                        let g = img.pixels[i + 1];
                        let b = img.pixels[i + 2];
                        let a = img.pixels[i + 3];
                        let brightness = (r + g + b) / 3;
                        let factor = brightness / 255;
                        
                        colored.pixels[i] = color.r * (1 - factor) + 255 * factor;
                        colored.pixels[i + 1] = color.g * (1 - factor) + 255 * factor;
                        colored.pixels[i + 2] = color.b * (1 - factor) + 255 * factor;
                        colored.pixels[i + 3] = a;
                    }
                    
                    colored.updatePixels();
                    return colored;
                };
                
                p.drawDotGrid = function() {
                    p.fill(255);
                    p.noStroke();
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            p.ellipse(x, y, p.dotSize, p.dotSize);
                        }
                    }
                };
                
                p.shuffleArray = function(array) {
                    let shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        let j = p.floor(p.random(i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };
                
                p.randomise = function() {
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    p.drawImages();
                };
                
                p.mousePressed = function() {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        p.randomise();
                    }
                };
            };
            
            currentSketch = new p5(sketch);
            currentP5Instance = currentSketch;
        }
        
        // 4:5 sketch - EXACTLY AS PROVIDED
        function load4x5Sketch() {
            const sketch = function(p) {
                p.images = [];
                p.selectedIndices = [];
                p.scalePercent = 0.88;
                
                // Dot grid variables
                p.dotRows = 11;
                p.dotCols = 9;
                p.dotSize = 6;
                
                // Color palette
                p.colors = [
                    {r: 168, g: 31, b: 35},
                    {r: 239, g: 214, b: 21},
                    {r: 232, g: 114, b: 36},
                    {r: 39, g: 76, b: 35},
                    {r: 28, g: 90, b: 153}
                ];
                
                p.areaDots = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                };
                
                p.preload = function() {
                    for (let i = 1; i <= 11; i++) {
                        const num = i.toString().padStart(2, '0');
                        p.images[i-1] = p.loadImage(`images/Riso-Illustrations-${num}.jpg`);
                    }
                };
                
                p.setup = function() {
                    // Use fixed dimensions from the second file
                    const canvas = p.createCanvas(720, 900);
                    // Create a wrapper div for the canvas
                    const canvasElement = canvas.elt;
                    const canvasDiv = document.createElement('div');
                    canvasDiv.className = 'p5-canvas';
                    canvasDiv.style.width = '100%';
                    canvasDiv.style.height = '100%';
                    canvasDiv.style.display = 'flex';
                    canvasDiv.style.justifyContent = 'center';
                    canvasDiv.style.alignItems = 'center';
                    canvasDiv.appendChild(canvasElement);
                    p5Container.appendChild(canvasDiv);
                    
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    
                    p.calculateAreaDots();
                    p.drawImages();
                };
                
                p.calculateAreaDots = function() {
                    for (let area in p.areaDots) {
                        p.areaDots[area] = [];
                    }
                    
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    const topHeight = p.height * 0.30;
                    const bottomHeight = p.height * 0.70;
                    const leftWidth = p.width * 0.30;
                    const rightWidth = p.width * 0.70;
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            
                            if (y < topHeight) {
                                p.areaDots.top.push({x: x, y: y, row: row, col: col});
                            } else if (x > rightWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.right.push({x: x, y: y, row: row, col: col});
                                }
                            } else if (y > bottomHeight) {
                                p.areaDots.bottom.push({x: x, y: y, row: row, col: col});
                            } else if (x < leftWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.left.push({x: x, y: y, row: row, col: col});
                                }
                            }
                        }
                    }
                };
                
                p.drawImages = function() {
                    p.background(255);
                    p.drawDotGrid();
                    p.blendMode(p.MULTIPLY);
                    
                    const areas = ["top", "right", "bottom", "left"];
                    let shuffledAreas = p.shuffleArray([...areas]);
                    
                    let selectedColors = [];
                    let availableColorIndices = [0, 1, 2, 3, 4];
                    
                    while (selectedColors.length < 4) {
                        let r = p.floor(p.random(availableColorIndices.length));
                        let colorIndex = availableColorIndices[r];
                        selectedColors.push(p.colors[colorIndex]);
                        availableColorIndices.splice(r, 1);
                    }
                    
                    for (let i = 0; i < p.selectedIndices.length; i++) {
                        let img = p.images[p.selectedIndices[i]];
                        let area = shuffledAreas[i];
                        let color = selectedColors[i];
                        
                        if (img && img.width > 0 && p.areaDots[area].length > 0) {
                            let coloredImage = p.colorizeImage(img, color);
                            let w = img.width * p.scalePercent;
                            let h = img.height * p.scalePercent;
                            let randomDot = p.random(p.areaDots[area]);
                            let x = randomDot.x - w/2;
                            let y = randomDot.y - h/2;
                            p.image(coloredImage, x, y, w, h);
                        }
                    }
                    
                    p.blendMode(p.BLEND);
                };
                
                p.colorizeImage = function(img, color) {
                    let colored = p.createGraphics(img.width, img.height);
                    colored.image(img, 0, 0);
                    colored.loadPixels();
                    img.loadPixels();
                    
                    for (let i = 0; i < img.pixels.length; i += 4) {
                        let r = img.pixels[i];
                        let g = img.pixels[i + 1];
                        let b = img.pixels[i + 2];
                        let a = img.pixels[i + 3];
                        let brightness = (r + g + b) / 3;
                        let factor = brightness / 255;
                        
                        colored.pixels[i] = color.r * (1 - factor) + 255 * factor;
                        colored.pixels[i + 1] = color.g * (1 - factor) + 255 * factor;
                        colored.pixels[i + 2] = color.b * (1 - factor) + 255 * factor;
                        colored.pixels[i + 3] = a;
                    }
                    
                    colored.updatePixels();
                    return colored;
                };
                
                p.drawDotGrid = function() {
                    p.fill(255);
                    p.noStroke();
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            p.ellipse(x, y, p.dotSize, p.dotSize);
                        }
                    }
                };
                
                p.shuffleArray = function(array) {
                    let shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        let j = p.floor(p.random(i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };
                
                p.randomise = function() {
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    p.drawImages();
                };
                
                p.mousePressed = function() {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        p.randomise();
                    }
                };
            };
            
            currentSketch = new p5(sketch);
            currentP5Instance = currentSketch;
        }
        
        // 9:16 sketch - EXACTLY AS PROVIDED
        function load9x16Sketch() {
            const sketch = function(p) {
                p.images = [];
                p.selectedIndices = [];
                p.scalePercent = 0.85;
                
                // Dot grid variables
                p.dotRows = 12;
                p.dotCols = 8;
                p.dotSize = 6;
                
                // Color palette
                p.colors = [
                    {r: 168, g: 31, b: 35},
                    {r: 239, g: 214, b: 21},
                    {r: 232, g: 114, b: 36},
                    {r: 39, g: 76, b: 35},
                    {r: 28, g: 90, b: 153}
                ];
                
                p.areaDots = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                };
                
                p.preload = function() {
                    for (let i = 1; i <= 11; i++) {
                        const num = i.toString().padStart(2, '0');
                        p.images[i-1] = p.loadImage(`images/Riso-Illustrations-${num}.jpg`);
                    }
                };
                
                p.setup = function() {
                    // Use fixed dimensions from the second file
                    const canvas = p.createCanvas(506.25, 900);
                    // Create a wrapper div for the canvas
                    const canvasElement = canvas.elt;
                    const canvasDiv = document.createElement('div');
                    canvasDiv.className = 'p5-canvas';
                    canvasDiv.style.width = '100%';
                    canvasDiv.style.height = '100%';
                    canvasDiv.style.display = 'flex';
                    canvasDiv.style.justifyContent = 'center';
                    canvasDiv.style.alignItems = 'center';
                    canvasDiv.appendChild(canvasElement);
                    p5Container.appendChild(canvasDiv);
                    
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    
                    p.calculateAreaDots();
                    p.drawImages();
                };
                
                p.calculateAreaDots = function() {
                    for (let area in p.areaDots) {
                        p.areaDots[area] = [];
                    }
                    
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    const topHeight = p.height * 0.28;
                    const bottomHeight = p.height * 0.72;
                    const leftWidth = p.width * 0.28;
                    const rightWidth = p.width * 0.72;
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            
                            if (y < topHeight) {
                                p.areaDots.top.push({x: x, y: y, row: row, col: col});
                            } else if (x > rightWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.right.push({x: x, y: y, row: row, col: col});
                                }
                            } else if (y > bottomHeight) {
                                p.areaDots.bottom.push({x: x, y: y, row: row, col: col});
                            } else if (x < leftWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.left.push({x: x, y: y, row: row, col: col});
                                }
                            }
                        }
                    }
                };
                
                p.drawImages = function() {
                    p.background(255);
                    p.drawDotGrid();
                    p.blendMode(p.MULTIPLY);
                    
                    const areas = ["top", "right", "bottom", "left"];
                    let shuffledAreas = p.shuffleArray([...areas]);
                    
                    let selectedColors = [];
                    let availableColorIndices = [0, 1, 2, 3, 4];
                    
                    while (selectedColors.length < 4) {
                        let r = p.floor(p.random(availableColorIndices.length));
                        let colorIndex = availableColorIndices[r];
                        selectedColors.push(p.colors[colorIndex]);
                        availableColorIndices.splice(r, 1);
                    }
                    
                    for (let i = 0; i < p.selectedIndices.length; i++) {
                        let img = p.images[p.selectedIndices[i]];
                        let area = shuffledAreas[i];
                        let color = selectedColors[i];
                        
                        if (img && img.width > 0 && p.areaDots[area].length > 0) {
                            let coloredImage = p.colorizeImage(img, color);
                            let w = img.width * p.scalePercent;
                            let h = img.height * p.scalePercent;
                            let randomDot = p.random(p.areaDots[area]);
                            let x = randomDot.x - w/2;
                            let y = randomDot.y - h/2;
                            p.image(coloredImage, x, y, w, h);
                        }
                    }
                    
                    p.blendMode(p.BLEND);
                };
                
                p.colorizeImage = function(img, color) {
                    let colored = p.createGraphics(img.width, img.height);
                    colored.image(img, 0, 0);
                    colored.loadPixels();
                    img.loadPixels();
                    
                    for (let i = 0; i < img.pixels.length; i += 4) {
                        let r = img.pixels[i];
                        let g = img.pixels[i + 1];
                        let b = img.pixels[i + 2];
                        let a = img.pixels[i + 3];
                        let brightness = (r + g + b) / 3;
                        let factor = brightness / 255;
                        
                        colored.pixels[i] = color.r * (1 - factor) + 255 * factor;
                        colored.pixels[i + 1] = color.g * (1 - factor) + 255 * factor;
                        colored.pixels[i + 2] = color.b * (1 - factor) + 255 * factor;
                        colored.pixels[i + 3] = a;
                    }
                    
                    colored.updatePixels();
                    return colored;
                };
                
                p.drawDotGrid = function() {
                    p.fill(255);
                    p.noStroke();
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            p.ellipse(x, y, p.dotSize, p.dotSize);
                        }
                    }
                };
                
                p.shuffleArray = function(array) {
                    let shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        let j = p.floor(p.random(i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };
                
                p.randomise = function() {
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    p.drawImages();
                };
                
                p.mousePressed = function() {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        p.randomise();
                    }
                };
            };
            
            currentSketch = new p5(sketch);
            currentP5Instance = currentSketch;
        }
        
        // 16:9 sketch - EXACTLY AS PROVIDED
        function load16x9Sketch() {
            const sketch = function(p) {
                p.images = [];
                p.selectedIndices = [];
                p.scalePercent = 0.85;
                
                // Dot grid variables
                p.dotRows = 8;
                p.dotCols = 12;
                p.dotSize = 6;
                
                // Color palette
                p.colors = [
                    {r: 168, g: 31, b: 35},
                    {r: 239, g: 214, b: 21},
                    {r: 232, g: 114, b: 36},
                    {r: 39, g: 76, b: 35},
                    {r: 28, g: 90, b: 153}
                ];
                
                p.areaDots = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                };
                
                p.preload = function() {
                    for (let i = 1; i <= 11; i++) {
                        const num = i.toString().padStart(2, '0');
                        p.images[i-1] = p.loadImage(`images/Riso-Illustrations-${num}.jpg`);
                    }
                };
                
                p.setup = function() {
                    // Use fixed dimensions from the second file
                    const canvas = p.createCanvas(900, 506.25);
                    // Create a wrapper div for the canvas
                    const canvasElement = canvas.elt;
                    const canvasDiv = document.createElement('div');
                    canvasDiv.className = 'p5-canvas';
                    canvasDiv.style.width = '100%';
                    canvasDiv.style.height = '100%';
                    canvasDiv.style.display = 'flex';
                    canvasDiv.style.justifyContent = 'center';
                    canvasDiv.style.alignItems = 'center';
                    canvasDiv.appendChild(canvasElement);
                    p5Container.appendChild(canvasDiv);
                    
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    
                    p.calculateAreaDots();
                    p.drawImages();
                };
                
                p.calculateAreaDots = function() {
                    for (let area in p.areaDots) {
                        p.areaDots[area] = [];
                    }
                    
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    const topHeight = p.height * 0.28;
                    const bottomHeight = p.height * 0.72;
                    const leftWidth = p.width * 0.28;
                    const rightWidth = p.width * 0.72;
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            
                            if (y < topHeight) {
                                p.areaDots.top.push({x: x, y: y, row: row, col: col});
                            } else if (x > rightWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.right.push({x: x, y: y, row: row, col: col});
                                }
                            } else if (y > bottomHeight) {
                                p.areaDots.bottom.push({x: x, y: y, row: row, col: col});
                            } else if (x < leftWidth) {
                                if (y >= topHeight && y <= bottomHeight) {
                                    p.areaDots.left.push({x: x, y: y, row: row, col: col});
                                }
                            }
                        }
                    }
                };
                
                p.drawImages = function() {
                    p.background(255);
                    p.drawDotGrid();
                    p.blendMode(p.MULTIPLY);
                    
                    const areas = ["top", "right", "bottom", "left"];
                    let shuffledAreas = p.shuffleArray([...areas]);
                    
                    let selectedColors = [];
                    let availableColorIndices = [0, 1, 2, 3, 4];
                    
                    while (selectedColors.length < 4) {
                        let r = p.floor(p.random(availableColorIndices.length));
                        let colorIndex = availableColorIndices[r];
                        selectedColors.push(p.colors[colorIndex]);
                        availableColorIndices.splice(r, 1);
                    }
                    
                    for (let i = 0; i < p.selectedIndices.length; i++) {
                        let img = p.images[p.selectedIndices[i]];
                        let area = shuffledAreas[i];
                        let color = selectedColors[i];
                        
                        if (img && img.width > 0 && p.areaDots[area].length > 0) {
                            let coloredImage = p.colorizeImage(img, color);
                            let w = img.width * p.scalePercent;
                            let h = img.height * p.scalePercent;
                            let randomDot = p.random(p.areaDots[area]);
                            let x = randomDot.x - w/2;
                            let y = randomDot.y - h/2;
                            p.image(coloredImage, x, y, w, h);
                        }
                    }
                    
                    p.blendMode(p.BLEND);
                };
                
                p.colorizeImage = function(img, color) {
                    let colored = p.createGraphics(img.width, img.height);
                    colored.image(img, 0, 0);
                    colored.loadPixels();
                    img.loadPixels();
                    
                    for (let i = 0; i < img.pixels.length; i += 4) {
                        let r = img.pixels[i];
                        let g = img.pixels[i + 1];
                        let b = img.pixels[i + 2];
                        let a = img.pixels[i + 3];
                        let brightness = (r + g + b) / 3;
                        let factor = brightness / 255;
                        
                        colored.pixels[i] = color.r * (1 - factor) + 255 * factor;
                        colored.pixels[i + 1] = color.g * (1 - factor) + 255 * factor;
                        colored.pixels[i + 2] = color.b * (1 - factor) + 255 * factor;
                        colored.pixels[i + 3] = a;
                    }
                    
                    colored.updatePixels();
                    return colored;
                };
                
                p.drawDotGrid = function() {
                    p.fill(255);
                    p.noStroke();
                    const horizontalSpacing = p.width / (p.dotCols - 1);
                    const verticalSpacing = p.height / (p.dotRows - 1);
                    
                    for (let row = 0; row < p.dotRows; row++) {
                        for (let col = 0; col < p.dotCols; col++) {
                            const x = col * horizontalSpacing;
                            const y = row * verticalSpacing;
                            p.ellipse(x, y, p.dotSize, p.dotSize);
                        }
                    }
                };
                
                p.shuffleArray = function(array) {
                    let shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        let j = p.floor(p.random(i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };
                
                p.randomise = function() {
                    p.selectedIndices = [];
                    while (p.selectedIndices.length < 4) {
                        let r = p.floor(p.random(11));
                        if (!p.selectedIndices.includes(r)) {
                            p.selectedIndices.push(r);
                        }
                    }
                    p.drawImages();
                };
                
                p.mousePressed = function() {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        p.randomise();
                    }
                };
            };
            
            currentSketch = new p5(sketch);
            currentP5Instance = currentSketch;
        }
        
        // Handle window resize
        window.addEventListener('resize', updateCanvasWrapperSize);
        
        // Control panel event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Aspect ratio button click handlers
            document.querySelectorAll('.aspect-button').forEach(button => {
                button.addEventListener('click', function() {
                    // Get the aspect ratio and update canvas wrapper size
                    const aspectRatio = this.getAttribute('data-aspect');
                    const aspectMap = {
                        '16:9': 0,
                        '9:16': 1,
                        '4:5': 2,
                        '3:2': 3,
                        '1:1': 4
                    };
                    
                    if (aspectMap.hasOwnProperty(aspectRatio)) {
                        currentSizeIndex = aspectMap[aspectRatio];
                        updateCanvasWrapperSize();
                        updateActiveButton();
                        
                        // Load the appropriate sketch
                        loadSketch(aspectRatio);
                    }
                });
            });
            
            // Initialize with 3:2 active
            updateActiveButton();
            
            // Load initial sketch (3:2)
            loadSketch('3:2');
            
            // Pun input event listener - auto-uppercase and enforce character limit
            punInput.addEventListener('input', function() {
                // Convert to uppercase
                this.value = this.value.toUpperCase();
                
                // Limit characters
                if (this.value.length > MAX_CHARACTERS) {
                    this.value = this.value.substring(0, MAX_CHARACTERS);
                }
                updateTextOverlay();
            });
            
            // Randomise button event listener
            document.getElementById('randomise-btn').addEventListener('click', function() {
                // If we have a p5 instance, call its randomise function
                if (currentP5Instance && currentP5Instance.randomise) {
                    currentP5Instance.randomise();
                }
            });
            
            // Download button event listener
            document.getElementById('download-btn').addEventListener('click', function() {
                downloadCanvas();
            });
            
            // Initialize character counter
            updateTextOverlay();
        });
    </script>
</body>
</html>